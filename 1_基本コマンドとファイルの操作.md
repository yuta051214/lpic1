# 基本とコマンド

## 基本

### シェル変数

- 設定されたシェルだけが使用する変数
- 子プロセスには引き継がれない
- exportしていない状態の変数
- 一覧：`set`
- 定義：`TEST="test"`
- 参照：`$TEST`（ もしくは  `${TEST}` ）
- 削除：`unset TEST`

### 環境変数

- 設定されたシェルとそのシェルで起動したプログラムが使用する変数
- 子プロセスに引き継がれる
- exportコマンドにより定義する
- 一覧：`env` / `printenv`
- 定義：`export TEST="test"`
- 参照：`$TEST`（ もしくは  `${TEST}` ）
- 削除：`unset $TEST`

#### 一時的な環境変数を設定してコマンドを実行

- `MY_VAR="hello" python script.py`

#### パスを通す（$PATHの先頭にパスを追加する）

- `export PATH="/my/custom/path:$PATH"`

#### ログイン時に永続的に環境変数を設定したいとき

1. `echo 'export EDITOR=vim' >> ~/.bashrc`  
1. `source ~/.bashrc`（`.bashrc` に書かれた内容を現在のシェルに適用する）

- 通常のターミナルや **非ログインシェル** では `~/.bashrc` が読み込まれる  
  **ログインシェル** の時点でも適用したい場合は `~/.bash_profile` から `~/.bashrc` を呼び出す  
  `~/.bash_profile` に以下を追加して、ログイン時に `~/.bashrc` を呼び出すようにする  

```
if [ -f ~/.bashrc ]; then		#ホームディレクトリに .bashrc があるか
	. ~/.bashrc		#.bashrc を現在のシェルに適用する（.はsorceの短縮形）
fi
```

### スタイルガイド
- コマンド置換
	- `$(date)`：推奨
	- `date`：古い、非推奨
- 変数の参照
	- `${変数}`：文字列の中などで分かりやすい、推奨
	- `$変数`：普通
- 算術演算
	- `$(( a + b ))`

### リダイレクト

- `>`：上書き
- `>>`：追記
- `(date;pwd;ls)>>file.log`
	- 上記３つのコマンド出力をファイルに追記する
- 標準入力として
	- 例）`tr 'A-Z' 'a-z' < file.txt`（＝ `cat file.txt | tr 'A-Z' 'a-z'`）

### ファイル記述子

- 0：標準入力
- 1：標準出力
- 2：標準エラー出力
- `1>&2`
	- `1>`：標準出力をリダイレクトする
	- `&2`：標準エラー出力と同じ出力先に

### ヒアドキュメント

- `command <<EOF 〜 EOF`
	- 指定した文字列（EOF）が現れるまでの内容を、コマンドへの標準入力として扱う

### /dev/null

- このファイルに書かれたものはすべて消去される
- `command > /dev/null 2>&1`
	- `> /dev/null`：標準出力先を /dev/null にする
	- `2>&1` ：標準エラー出力先を標準出力先と同じにする

### シェル演算子

- `cmdA ; cmdB`
	- 順々に実行する
- `cmdA && cmdB`
	- 前のコマンドが実行できれば、後のコマンドを実行する
- `cmdA || cmdB`
	- 前のコマンドが実行できなかったならば、後のコマンドを実行する

### 改行コード

- \n：改行（newline）、行を分ける（Linux）
- \r：復帰（return）、行頭に戻る（Windows）
- \t：タブ（tab）、横方向のタブ、インデント
- LinuxとWindowsの改行コード
	- Linux は \n のみ、Windows は \r\n
	- よって、windowsで作ったファイルをLinuxで正しく表示させるには「\r」を削除する必要がある
		- `tr -d '\r' < windows.txt > linux.txt` を実行する

### フィールド区切り文字

- IFS (Internal Field Separator：内部フィールド区切り文字)  は、Bashがデータを分割する際の区切り文字として使用する
- デフォルトでは **スペース・タブ・改行**（つまり `IFS=$' \t\n'`）が区切り文字として使用されている
- 入力にスペースを含む行や文字列がある場合、意図しない分割を防ぐために、IFS を改行とタブのみに設定することがよくあるらしい

### クオート

- シングルクオート
	- 単に文字列として扱う
- ダブルクオート
	- 文字列として扱うだけでなく、変数展開とコマンド置換が可能

### オプションに対する引数について

- とりあえず、以下のようにしてみようと思う
	- 文字列を引数にとる場合は「'abc'」「"abc"」のようにクオートを用いる
	- 数値を引数にとる場合は「-f 1」のようにスペースを空けて書き、詰めたりしない
		- 実際は「-f1」「-f "1"」でも問題なく解釈される





## コマンド

### `pwd` / `echo ${PWD}`
- ワーキングディレクトリを表示

### set 
- 現在のシェルにパラメータやオプションを設定する
- -o：有効にする
- +o：無効にする
- 使用例：
```bash
set -o errexit		#コマンドが失敗したら即終  =>  エラーを見逃さない
set -o nounset		#未定義の変数を参照するとエラー  =>  タイポ・定義漏れを防ぐ
set -o pipefail		#パイプ内のどの失敗も検出（これだけだと検出するのみで、
					# 後続のコマンドは実行されてしまうため errexit と併用する）
```

### PS1

bashのコマンドプロンプト

### PS2

bashの2次プロンプト、つまり継続行（ > ）のこと

### cd ~yuta

現在のログインユーザに関わらず、~以降に指定されたユーザのホームディレクトリへ移動する

### man

- 使用例：
	- `man crontab`：セクション1から順に検索し、最初に見つかったマニュアルを表示する
	- `man 1 crontab`：セクション 1（コマンドの使い方など）
	- `man 5 crontab`：セクション 5（設定ファイルの書式など）
- 関連ファイル：
	- `/usr/share/man`：標準的なパッケージが提供するマニュアル
	- `/usr/local/share/man`：ユーザが独自にインストールしたプログラムのマニュアル

### history

- コマンド実行履歴を表示する
- `~/.bash_history`：コマンド実行履歴の保存先
- シェル変数 `HISTFILE=~/.bash_history`

### su

- 一時的にアカウントを指定したユーザに切り替える
- `su -` / `su - root`：rootユーザに切り替え

### sudo

- 事前に管理者から許可されている管理用コマンドを実行する

### mkdir

- -p：親ディレクトリも一緒に作成する

### touch

- `touch file`：アクセス時刻と修正時刻を現在の時刻に変更（または新規ファイルの作成）
- `touch 06030800 file`：タイムスタンプを 6/3 8時 に変更

### mv 

- -f：移動先に同名ファイルが存在しても、強制的に上書きする
- -I：移動先に同名ファイルが存在する場合、上書きするか確認する
- mvコマンドは、特にオプションを指定せずとも、サブディレクトリを含めてまるっと移動できる
	- cpコマンドと違って、中身を読み取る必要がない
	- つまり、データをコピーせず、ファイルシステム上の参照を変更するだけ（同一ファイルシステムの場合）

### -r（再帰）を必要とするコマンド

- cp / scp : ディレクトリをコピーするとき
- rm：ディレクトリを削除するとき（ -r なしではディレクトリを削除できない）
- chmod / chown：あるディレクトリ以下の全てのファイル・ディレクトリの権限/所有者を変更するとき（大文字の -R ）

### ls

- -F：ファイルタイプを表示（/：ディレクトリ、*：実行可能ファイル、@：シンボリックリンク）
- -a：隠しファイルの表示（.：隠しファイル）
- -l：詳細情報を表示
- -d：ディレクトリ情報の表示
- `ls -ltr`：更新日時の新しいものが一番下に出る順番で詳細表示する
- ディレクトリのみを表示するとき
	- `ls -l | grep ^d`：アクセス権表示が drwxr... のように d で始まる行（＝ディレクトリ）だけを抽出する
	- `find . -maxdepth 1 -type d`：現在のディレクトリにあるディレクトリのみを表示する

### ディレクトリの削除

- 安全に空ディレクトリだけを削除したい：`rmdir`
- 空・中身あり両方を一括で削除したい：`rm -r`

### tar

- 格納 tar・圧縮 zip
	- `tar czf archive.tar.gz  directory/`
		- c：（create）アーカイブの作成
		- z：（zip）gzipで圧縮
		- f：ファイル名を指定
- 解凍 unzip・展開 extract
	- `tar xzf archive.tar.gz`
		- x：（extract）展開
- 一覧表示
	- `tar tzf archive.tar.gz`
		- t：（table）一覧表示
- アーカイブファイルの拡張子
	- .tar.gzip（＝ .tgz）
	- .tar.bz2（＝ .tbz2）
	- .tar.xz（＝ .txz）
- 主な規格
	- 圧縮：gzip、bzip2、xz
	- 解凍：gunzip、bunzip2、unxz

### less

- lessはmoreより高機能で、こっちの方がよく使われる
- オプション
	- -N：行番号を表示
- 操作
	- スペース / b：１ページ進む / 戻る
	- /文字列：下方向に検索
	- n / N：検索の次 / 前

### cat

- 行番号を付与して表示する：`cat -n`

### file 

- ファイルの種類（type）を表示する：`file hogehoge.txt`

### tee

- `ls -l | tee log.txt`
	- log.txtに出力、さらに画面にも出力
- `nl /etc/passwd | tee log.txt | head -3`
	- nl：cat -n と同じ（number lines の意味）
	- log.txtに出力、さらにheadに渡す

### grep

- オプション
	- -v：一致する行以外を表示（一致する行を除外する）
	- -i：大文字と小文字を区別しない
	- -n：行番号を表示する
	- -l：パターンと一致した行を含むファイルの **ファイル名だけ** を表示する
	- -r：再帰的にディレクトリをたどる
	- -e：「-e "aaa" -e "bbb"」のように複数のパターンを指定できる
	- -E：egrepと同じで、「|」「()」「+」「?」が使えるようになる
- `grep "abc" /etc/*.log`：一致した行を表示
- `grep -l "abc" /etc/*.log`：一致した行を含むファイル名を表示
- `grep -r "abc" /etc`：指定したディレクトリ以下を再帰的に検索する
- `grep -r -i -E "((やまだ|山田) *(たろう|太郎) | yamada +tarou)" /home/docs/users/`
	- |：または
	- *：直前の文字が０回以上連続
	- +：直前の文字が1回以上連続

### head

- `head -n 5`
	- ファイルの先頭から5行分を表示する
- `head -n -5`
	- 最後の5行を除いた、残りすべての行を表示する
	- 不要な末尾部分を指定してそれ以外を取得する

### tail

- `tail -n 5`
	- ファイルの末尾から5行分を表示する
- `tail -n +6`
	- 最初の5行を除いた、残りすべての行を表示する
	- 不要な先頭部分を指定してそれ以外を取得するって感じ
- `tail -f /var/log/syslog | grep "ERROR"`
	- syslogに "ERROR" を含む行が追加されたときだけ表示する
	- -f：（follow）常にファイルの最終行部分を読み続けようとする（ログファイルのモニタなどに有効）

### find

- 指定したディレクトリ以下のファイルやディレクトリを条件付きで検索する
- 使用例：
	- `find . -name "*.txt"`：カレントディレクトリ以下の .txt ファイルを検索
	- `find /var/log -type f`：/var/log 以下のファイルのみを検索
	- `find . -type d`：カレントディレクトリ以下のディレクトリのみを検索
	- 他にファイルサイズの指定や更新日時の指定などもある

### tr

- TRanslateの略、文字の置換・削除・連続文字の圧縮につかう
- オプション：
	- -d：（delete）合致した文字を削除する
	- -s：（squeeze repeats）文字の繰り返しを1文字に置き換える
- 使用例：
	- 大文字 ⇔ 小文字の変換（ケースの統一）
		- `cat file.txt | tr 'A-Z' 'a-z'`（＝ `tr 'A-Z' 'a-z' < file.txt`）
	- 全ての改行を削除
		- `cat file.txt | tr -d '\n'`
	- スペースの繰り返しを圧縮
		- `echo "a b  c      d" | tr -s ' '`
	- 特定の文字を他の文字に変える（電話番号や日付などの記号整形に）
		- `echo "123-456-7890" | tr '-' ':'`

### cut

- ファイル内の行中の特定部分のみ取り出すにはcutコマンド
- オプション
	- -f：指定されたフィールドだけを表示する
	- -d：デリミタを指定する。デフォルトはタブ。
	- -c：指定された位置の文字だけを表示する
- 使用例：
	- `cut -d ":" -f 1,7 /etc/passwd`：ユーザ名とログインシェルを表示する
	- `ps ax | cut -c 1-5`：先頭5文字（プロセスID）を取り出す　※ps auxとすると先頭がユーザ名になる

### awk

- テキストをフィールド単位で処理・抽出・集計できるパターン処理ツール
- デフォの FS(Field Separator)は「スペース・タブ」
- 使用例：
	- `echo a b c d | awk '{print $2, $3}'`　=>　b c
	- `echo "2023-11-30" | awk -F "-" '{print $1}'`　=>　2023
		- FSをハイフンに変更している
		- （CSVなら `-F ","` で分割できる）

### sed

- テキストを行単位で置換・削除・挿入するためのストリームエディタ
- s：（substitute）置換の意味
- g：（global）行内に複数の一致があった場合もそれら全てを対象とするの意味
- 使用例：
	- `echo 'a b  c    d' | sed 's/ //g'`：全ての空白を削除
	- `echo '2025/12/23' | sed 's/\///g'`：全てのスラッシュを削除

### rev

- 文字列を反転させる
- 使いどころ
	- ファイル名を反転してその一部（例えば拡張子）を抽出する
	- 一旦 文字列を反転させてから cut -f 1 で先頭フィールドを取得し、再度反転することで 結果として常に **「末尾からのフィールド処理」** ができるので便利
- 使い方：
	- `echo 'report.abc.pdf' | rev | cut -d '.' -f 1 | rev`
		- 「.〜」がいくつあっても、末尾のフィールド（pdf）のみを取得できる

### xargs

- 標準入力を受け取り、それを後続のコマンドの引数として渡す
	- `find . -name "*.log" | xargs rm`
		- カレントディレクトリ以下の .log ファイルをすべて削除
- 後続にコマンドがない場合、標準入力をスペース区切りで1行に連結して標準出力に出す（xargs echo みたいな感じ）
	- `HOGE=$(find . -maxdepth 1 -name "*.txt" | xargs)`

### seq

- `HOGE=$(seq -f "%02g" 1 12 | xargs)`
	- 1〜12の数値を 2 桁のゼロ埋め（01, 02, … 12）で生成する（改行区切り）
	- 改行区切りをスペース区切りの1行に変換して変数に格納する

### wc

- オプション
	- -l：行数だけを出力する
	- -w：単語数だけを出力する
- 使用例：
	- `wc -l /etc/password`：OSのユーザ数を数える

### sort

- 行を並び替えて表示する
- 使用例：
	- `sort -r file.txt`：逆順（降順）で表示
	- `sort -t ':' -k 3 -n users.txt`：「:」区切りのファイルを3列目の数値順でソート

### uniq

- 連続する重複行を省略する
- オプション：
	- -c：重複した回数を各行の先頭に表示
	- -d：重複している行のみを表示
	- -u：一度だけ現れる行のみを表示
	- -i：大文字小文字を区別しない
- 使用例：
	- `sort items.txt | uniq`

### od（Octal Dump）

- ファイルの内容を8進数などで表示するコマンド

### expr

- 算術評価のコマンド、だが `$((  ))` で代替可能なうえ推奨されているので注意
	- `result=$(expr ${a_cnt} + ${b_cnt})`

### split

- ファイルを指定した大きさに分割し、以下のようなファイル名で保存する
	- ファイル名の指定なしの場合：プレフィックスは「x」、サフィックスは「aa, ab, ac ...」
- オプション
	- -l：分割する行数を指定
	- -d：サフィックスを数字にする（00, 01, 02 ...）
- 使用例：
	- `split -l 5 fileA`　=>　fileA、xaa、xab
	- `split -l 5 -d fileA split_file`　=>　fileA、split_file00、split_file01
		- 第２引数 split_file はプレフィックスの指定

### md5sum, sha256sum, sha512sum

- ハッシュ値を計算するコマンド
- ログイン時のユーザ認証などで使用する